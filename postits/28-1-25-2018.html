<!DOCTYPE html>
<html>
<head>

	<!-- style -->
	<link rel="stylesheet" href="../css/style.css">

	<!-- favicon -->
	<link rel="icon" href="../things/compass.png">

	<title>28</title>
</head>
<body>

	<a href="../index.html">..</a>

	<br></br>

	The thing about security is that you can almost never be perfect, rather you just have to be better than the attacker. While this sounds conceivable in theory, the principles in combination are a difficult puzzle to piece. Let's discuss some of these key principles to implement.

	<br></br>

	<ul><b>Know your threat model.</b> Think of this as the brainstorming before you build a complex security procedure or system. You have to at least predict what sort of attackers you might encounter in order to prepare cases that will prevent their attacks from going through.</ul>

	<ul><b>Economics.</b> Building secure code takes a lot of time and money, on the other side it also takes a lot of capital to attack a system. Even if your program isn't completely secure, you just have to make it more expensive for the attacker to attack your code than for the reward they are seeking. If this becomes the case for them, they will likely not attempt to attack your program and look for something that will have a better work-reward balance. However, don't forget to consider how much this building is costing you.</ul>

	<ul><b>Don't rely on security through obscurity.</b> Kerckhoff's principle reads, "A cryptosystem should be secure even if everything about the system, except the key, is public knowledge." Even if you built a beautiful defence, assume that it's already well-known because eventually an attacker can figure out the algorithm. But if you keep the key secure, they still won't be able to get through. It's pertinent to keep the key a secret over the cryptosystem because it's much easier and faster to change the key than it is the entire system.</ul>

	<ul><b>Defence in depth.</b> Think of it like having layers of different defence systems. There are typically multiple actors in this scenario, involving a combination of something you know (password), something you have (pin sent to phone) and something you are (biometrics). Two factor authorisations are a good example, where you put your login information in, then you're texted a pin to input as verification that it's you logging in. Make sure to make these mechanisms different enough so that if one layer is broken through, the other presents a new problem instead of a slightly altered version of what they just broke through.</ul>

	<ul><b>Human factors.</b> Your cryptosystem is beautiful, and the complexity of login information is genius with a minimum twelve character, two special character, one upper case, three numbers minimum. You've done everything right... Except consider that your users are humans. When their own verifiables are that complex, they're going to write their account information on stickies posted all over their laptop. Yikes. This is one of the times where your defence can't be perfect, even if you've done what you can it's considerably less secure if the information lingers tangibly.</ul>

	<ul><b>Division of trust.</b> With security, everything is sensitive. The paranoia can even make you distrust those you work with. Movie theatres understand your feeling. They bother to split one job into to diminish the chance of malicious exchange. One person sells you a ticket, another person lets you into the theatre. They do this to prevent their own employees from pocketing money and letting people into films. Obviously, this model doesn't completely eliminate the possibility of that still happening, but they value it enough to split the job into two and pay an extra person.</ul>
	
</body>
</html>
